
local NewMapMonCount = 1500
local NewActMonCount = 500

-- Example for debug console
--~ floor, rnd = math.floor, math.random
--~ monT1 = 44
--~ monT2 = 171
--~ X, Y, Z = XYZ(Party)

--~ Game.HostileTxt[floor(monT1/3)][floor(monT2/3)] = 4
--~ Game.HostileTxt[floor(monT2/3)][floor(monT1/3)] = 4

--~ for i = 1, 200 do
--~ 	mon = SummonMonster(monT1, rnd(X - 2000, X + 2000), rnd(Y - 2000, Y + 2000), Z + 200)
--~ 	mon.Group = 11
--~ 	mon = SummonMonster(monT2, rnd(X - 2000, X + 2000), rnd(Y - 2000, Y + 2000), Z + 200)
--~ 	mon.Group = 12
--~ end

-----------------------------------------

-- 0x61c540
local RefTable = {

-- Mon table

0x40123D, 0x401268, 0x401527, 0x401706, 0x40175A, 0x40192A, 0x40198A, 0x4019FC, 0x401A05, 0x401AA0, 0x401B7F, 0x401C7B, 0x401EA9,
0x40221A, 0x40224C, 0x402260, 0x40226C, 0x4023AD, 0x40279F, 0x402934, 0x402A80, 0x402BF6, 0x402DFF, 0x402E8F, 0x403164, 0x4031CB,
0x4032F0, 0x403401, 0x4034F6, 0x403580, 0x4036BE, 0x4036F9, 0x403700, 0x403707, 0x40370E, 0x4038DC, 0x403917, 0x40391E, 0x403925,
0x40392C, 0x403AAB, 0x403AE6, 0x403AED, 0x403AF4, 0x403AFB, 0x403CC0, 0x403CFB, 0x403D02, 0x403D09, 0x403D10, 0x403ECC, 0x403F2B,
0x403F32, 0x403F39, 0x403F40, 0x4040BF, 0x404122, 0x4041EB, 0x4042C2, 0x404538, 0x404542, 0x40454C, 0x404564, 0x404656, 0x404660,
0x40466A, 0x404682, 0x40480A, 0x4049EB, 0x404B2C, 0x404D7B, 0x4054AC, 0x4054B6, 0x4054C0, 0x4054D8, 0x4055DE, 0x406184, 0x4063D7,
0x40646A, 0x406501, 0x406955, 0x406A3F, 0x406B1C, 0x406BCC, 0x406C75, 0x406DC1, 0x406F5D, 0x40701E, 0x40705D, 0x407071, 0x40707D,
0x4072B2, 0x407367, 0x4074C1, 0x40778C, 0x4078EC, 0x4078F6, 0x407900, 0x407928, 0x407935, 0x4079D0, 0x4079D7, 0x4079E1, 0x407A09,
0x407A13, 0x408F1B, 0x409171, 0x4091D3, 0x409241, 0x4092B3, 0x409318, 0x40932F, 0x41D927, 0x42074C, 0x42158D, 0x4260F4, 0x42689E,
0x4268AB, 0x4268B2, 0x426912, 0x42693F, 0x4269CB, 0x4269D8, 0x4269DF, 0x426A54, 0x426E5F, 0x426F91, 0x426FEC, 0x426FFF, 0x427033,
0x427090, 0x42709E, 0x4270EE, 0x4278DC, 0x4278E9, 0x4278F0, 0x427B76, 0x427B80, 0x427B87, 0x427F23, 0x427F30, 0x427F3D, 0x427F55,
0x4284D5, 0x4284E2, 0x4284E9, 0x429B65, 0x429B78, 0x429B80, 0x429F59, 0x42A603, 0x42A7F3, 0x42A80B, 0x42A819, 0x42A852, 0x42A860,
0x42A8D2, 0x42A8F1, 0x42A909, 0x42A917, 0x42A950, 0x42AA80, 0x42AD53, 0x42AF00, 0x42B593, 0x42B5A0, 0x42B5AD, 0x42B5C5, 0x42B63E,
0x42B734, 0x42B952, 0x42B95F, 0x42B96C, 0x42B984, 0x42BF3C, 0x42C3FF, 0x42C41E, 0x42C43A, 0x42C448, 0x42C498, 0x42C4D0, 0x42C4D7,
0x42C4E5, 0x42C4EC, 0x42C7EF, 0x42C7FC, 0x42C809, 0x42C821, 0x42CECB, 0x42D126, 0x42D917, 0x42D960, 0x42DCF2, 0x42DE34, 0x42DF76,
0x42EF1E, 0x42EF2B, 0x4309A1, 0x436A5F, 0x436A94, 0x436CA8, 0x436DA5, 0x436EDC, 0x437B39, 0x437F70, 0x438763, 0x438788, 0x438897,
0x438C84, 0x438E2E, 0x43CD7F, 0x43F2A9, 0x442A11, 0x44402C, 0x44588A, 0x4458AD, 0x4458BF, 0x4458CD, 0x4458E7, 0x4458F1, 0x445925,
0x445937, 0x445945, 0x445961, 0x44596B, 0x445B9C, 0x445BBC, 0x445E32, 0x445E4C, 0x445E62, 0x445E93, 0x445ED7, 0x4461D1, 0x44CE85,
0x44D21A, 0x44D293, 0x44D537, 0x44DDCC, 0x44E4EE, 0x455CBE, 0x45D655, 0x45D870, 0x45E891, 0x45EAAD, 0x45EB2F, 0x4614DE, 0x468823,
0x468B1C, 0x468B37, 0x468C12, 0x468C2D, 0x468E07, 0x46918C, 0x46A543, 0x46A668,           0x46AE6F, 0x46AF48, 0x46AF95, 0x46AFBB, -- 0x46A6F2,
0x46AFDF, 0x46AFFF, 0x46B0AC, 0x46B101, 0x46B120, 0x46B126, 0x46B166, 0x46B2F6, 0x46B343, 0x46B365, 0x46B42E, 0x46B467, 0x46B481,
0x46B4FA, 0x46B502, 0x46B509, 0x46B547, 0x46B567, 0x46B57A, 0x46B5C2, 0x46B5D5, 0x46B7F8, 0x46C9DD, 0x46E413, 0x46E900, 0x46E918,
0x46E930, 0x46E94A, 0x46EEEB, 0x46F1B3, 0x46FC85, 0x470239, 0x47024C, 0x4702C7, 0x4709B0, 0x4709B6, 0x4711D2, 0x4711DC, 0x4711E6,
0x4711ED, 0x471EAD, 0x473547, 0x47A717, 0x47A78C, 0x47CC50, 0x47DDEB, 0x47EAC4, 0x491EDE, 0x491EEB, 0x491EF2, 0x496C84, 0x497CFF,
0x4A8956, 0x4A8CE0, 0x4A8F58, 0x4A91FD, 0x4A9581, 0x4A98B8, 0x4B9E14, 0x4BA0E3, 0x4BE3DC}

-- 0x5091f0
local RefTable1 = {
0x401658, 0x401696, 0x40169F, 0x4016F9, 0x401887, 0x4018C3, 0x4018CC, 0x40191B, 0x40194C, 0x4019ED, 0x401A63, 0x401A93, 0x401E8C,
0x406170, 0x406809, 0x40682D, 0x46E8E4, 0x46F7B0}

-- 0x508a18
local RefTable2 = {
0x401652, 0x401687, 0x40168D, 0x4016AE, 0x4016B5, 0x4016BB, 0x401881, 0x4018B4, 0x4018BA, 0x4018DB, 0x4018E2, 0x4018E8, 0x40195D,
0x401A7B, 0x4016E3, 0x4016EE, 0x401982, 0x4019BB, 0x4019C4, 0x4019E0, 0x401A2A, 0x401A32, 0x401A45, 0x401A55, 0x401A6D, 0x401A85,
0x401E7C, 0x4026E3, 0x40615A, 0x40621F, 0x4067D8, 0x406853, 0x46E8D5, 0x46E976, 0x46F7A5, 0x46F7CC}

-- 0x508248
local RefTable3 = {
0x401C95, 0x401E9B, 0x4061A8, 0x4065D8, 0x4069E9, 0x406A69, 0x406D8F, 0x406F9F, 0x40722B, 0x4072C4, 0x4073D4, 0x40750B, 0x4077C4,
0x408F5E, 0x436994}

-- 0x507a78
local RefTable4 = {
0x401956, 0x4019AD, 0x4019CA, 0x401A1C, 0x401A38, 0x401A5E}


local function GetRefAdr(p, ref, prec, prec2)
	prec	= prec  or 0
	prec2	= prec2 or 0

	if p == nil then error("Address is nil.") end

	local cmd = mem.GetInstructionSize(p)
	local sh = 0
	while true do
		if sh >= cmd then
			break
		end
		local res = mem.u4[p+sh]
		if res >= ref - prec2 and res <= ref + prec then
			break
		end
		sh = sh + 1
	end
	return p+sh
end

local function Process(t, OldOrigin, NewOrigin, prec, prec2)
	local OldAddr
	local RefAddr
	for i, v in ipairs(t) do
		RefAddr = GetRefAdr(v, OldOrigin, prec, prec2)
		OldAddr = mem.u4[RefAddr]
		mem.u4[RefAddr] = NewOrigin + OldAddr - OldOrigin
	end
end

function events.GameInitialized2()

	local OldCount, NewCount = 500, NewMapMonCount
	mem.IgnoreProtection(true)

	if NewCount > OldCount then

		local OldPtr, NewPtr = 0x61c540, mem.StaticAlloc(0x3cc*NewCount + 0x70) + 0x50
		local MapMonPtr = NewPtr
		local ReInit = mem.asmproc([[
		pushad
		pushfd

		push 0x4f00b8
		push 0
		mov esi, ]] .. MapMonPtr .. [[;
		mov edi, ]] .. NewCount .. [[;

		@rep:
		mov ecx, esi
		call absolute 0x41d8c6
		add esi, 0x3cc
		dec edi
		jnz @rep

		pop eax
		pop eax

		popfd
		popad
		retn]])

		Process(RefTable, OldPtr, NewPtr, 0x900, 0)

		NewPtr = mem.StaticAlloc(NewCount * 8*2 + 0x10)
		Process(RefTable1, 0x5091f0, NewPtr, 0)

		NewPtr = mem.StaticAlloc(NewCount * 8*2 + 0x10)
		Process(RefTable2, 0x508a18, NewPtr, 0xa)

		NewPtr = mem.StaticAlloc(NewCount * 8*2 + 0x10)
		Process(RefTable3, 0x508248, NewPtr, 0)

		NewPtr = mem.StaticAlloc(NewCount * 8*2 + 0x10)
		Process(RefTable4, 0x507a78, NewPtr, 0)

		mem.u4[0x4ba084 + 2] = NewCount -- Summon monster
		mem.u4[0x44ce1e + 1] = NewCount -- Spawn monster
		mem.u4[0x47dda5 + 1] = NewCount -- Load map limit

		if NewCount > 1500 then
			-- Tricky move to patch MMPatch, hope it won't be needed in future.
			local MMPatchBase = mem.i4[0x46f743 + 1] + 0x46f748
			NewPtr = mem.StaticAlloc(NewCount*24)
			mem.u4[MMPatchBase + 0x9]  = NewPtr
			mem.u4[MMPatchBase - 0x13] = NewPtr
		end

			-- Adjust savegame size to fit new possible amount of monsters.
		local NewSaveSize = mem.u4[0x45d54a+1] + (NewCount - OldCount)*0x3cc

		mem.u4[0x40E8CB + 1] = NewSaveSize
		mem.u4[0x40E927 + 1] = NewSaveSize
		mem.u4[0x45CFA2 + 1] = NewSaveSize
		mem.u4[0x45D080 + 1] = NewSaveSize
		mem.u4[0x45D54A + 1] = NewSaveSize
		mem.u4[0x45E1E2 + 1] = NewSaveSize
		mem.u4[0x4AA9F4 + 1] = NewSaveSize
		mem.u4[0x4AAA0B + 2] = NewSaveSize
		mem.u4[0x4AAA11 + 2] = NewSaveSize

		mem.call(ReInit)

		-- Correct structures
		structs.o.GameMap.Monsters = p
		internal.SetArrayUpval(Game.Map.Monsters, "o", MapMonPtr)
		internal.SetArrayUpval(Game.Map.Monsters, "count", NewCount)

	end

	-- New limit of active monsters
	local NewActiveLimit = mem.StaticAlloc(4)
	mem.u4[NewActiveLimit] = NewActMonCount

	mem.asmpatch(0x4016DE, [[
	cmp eax, dword[ds:]] .. NewActiveLimit .. [[];
	pop edi
	pop esi]])

	mem.asmpatch(0x4016E9, [[
	jle absolute 0x4016f3
	push dword[ds:]] .. NewActiveLimit .. [[];
	pop eax]])

	mem.asmpatch(0x40196C, [[
	cmp edi, dword[ds:]] .. NewActiveLimit .. [[];
	jge absolute 0x40197a]])

	mem.asmpatch(0x401A4A, [[
	cmp eax, dword[ds:]] .. NewActiveLimit .. [[];
	pop edi
	pop esi]])

	mem.asmpatch(0x401A50, [[
	jle absolute 0x401a5a
	push dword[ds:]] .. NewActiveLimit .. [[];
	pop eax]])

-- Tactical phase, better to leave old limit here.
-- 	mem.asmpatch(0x406bb9, [[
-- 	cmp eax, dword[ds:]] .. NewActiveLimit .. [[];
-- 	jge absolute 0x406bdf
-- 	push dword[ds:]] .. NewActiveLimit .. [[];
-- 	pop eax
-- 	jmp absolute 0x406bdf]])

	mem.asmpatch(0x47024c, [[
	cmp eax, ]] .. NewCount*0x3cc .. [[;
	ja absolute 0x4702a6
	movsx eax, word [ds:eax + ]] .. mem.u4[0x47024f] .. [[];
	]])

	mem.IgnoreProtection(false)

end
